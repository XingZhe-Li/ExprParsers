## What is Regular Language

### 1. 递归构造定义（代数定义）

这是最基础的定义方式。给定一个有限字符集 $\Sigma$，在该字母表上的**正则语言**遵循以下递归规则：

* **基础情况**：
  
  * 空集 $\emptyset$ 是正则语言。
    
  * 只包含空字符串的集合 $\{\epsilon\}$ 是正则语言。
    
  * 对于每一个 $a \in \Sigma$，单元素集合 $\{a\}$ 是正则语言。
    
* **递归步骤**（闭包运算）：若 $L$ 和 $M$ 都是正则语言，则以下通过运算得到的结果也是正则语言：
  
  * **并集（Union）**：$L \cup M$
    
  * **连接（Concatenation）**：$L \cdot M$
    
  * **克莱尼星号（Kleene Star）**：$L^*$（即 $L$ 的零次或多次重复）
    

> **注意**：只有通过有限次上述运算得到的语言才是正则的。

* * *

### 2. 自动机定义（机器识别）

这是从“如何识别”的角度给出的定义：

> **定义**：如果一个语言 $L$ 可以被某个**有限状态自动机（DFA 或 NFA）**识别，那么 $L$ 就是正则语言。

* **DFA（确定有限自动机）**：对于每个状态和输入符号，有且只有一个转移目标。
  
* **NFA（非确定有限自动机）**：允许从一个状态出发，通过同一个符号进入多个可能的状态，甚至允许 $\epsilon$ 转移。
  
* **等价性**：由于 NFA 总是可以转换为等价的 DFA，所以它们定义的语言类是完全相同的。
  

* * *

### 3. 文法定义（产生式规则）

这是从“如何生成”的角度给出的定义（属于乔姆斯基 3 型文法）：

> **定义**：如果一个文法 $G = (V, \Sigma, R, S)$ 的所有产生式规则 $R$ 都符合以下形式之一，则它生成的语言是正则的：

* **右线性文法**：
  
  * $A \to a$
    
  * $A \to aB$
    
  * $A \to \epsilon$（其中 $A, B$ 是非终结符，$a$ 是终结符）
    

如果你把产生式写成 $A \to Ba$（左线性），它也是正则的，但你**不能在一个文法中混用**左线性位和右线性位，否则它可能会变成上下文无关文法（CFG）。

* * *

### 4. 正则语言的“界限”：泵引理 (Pumping Lemma)

并不是所有的语言都是正则的。正则语言最核心的限制在于它**没有无限的内存（栈）**。

**泵引理**指出：如果一个语言是正则的，那么对于足够长的字符串，总能找到一段可以被无限“泵起”（重复）的部分，而结果仍属于该语言。

* **经典反例**：$L = \{a^n b^n \mid n \ge 0\}$（如 $aabb, aaabbb$）。
  
  * 这个语言**不是**正则语言，因为自动机无法通过有限的状态“记住”前面出现了多少个 $a$，从而无法匹配相同数量的 $b$。
    
  * 这正是为什么你在做 HTML 解析（标签嵌套）时不能只用正则表达式，而必须用下推自动机（PDA）的原因。

> LL, LR 这些语言需要的状态机叫做下推状态机 (PDA)，与FA相比，他们多了个栈。

## What is LL Parser

我们通常讨论LL(1) Parser, LL Parser 的推导过程会计算两个Sets，一个Follow Sets，记录某一种非终结符可能跟随的终结符，一个First Sets，记录某一种非终结符号可能以什么终结符开始。 LL Parser 的具体解析流程就是根据这两个 Sets 来确定 是否存在语法错误，是否应该跳过当前非终结符（比如你的非终结符可能为空，那么下一个符号应该出现在Follow Sets中），根据下一个（如果为LL(k)就是下k个）替换当前解析的非终结符号（这个替换根据生成式确定，不能单独由两个Sets确定，如果匹配则pass）。当然LL语法会存在一些限制，比如要避免左递归，以及实际上可能会有向前看符号的冲突（展开冲突）。

手写递归解析（While 与 递归），Precedence Climbing（同级与升级），LL（语义动作的添加顺序）对左右结合的处理在代码示例中都已实现，不妨自己去看。

总体而言 LL Parser 还是比较全能的，而且手写递归解析 和 Precedence Climbing 其实也算是某种LL的变体，毕竟他们都是Top-Down 方法。

## What is LR Parser

LR Parser通常分为四种，LR(0),SLR,LALR,LR(1)，他们的性能（不是说速度，而是解析能力）从弱到强也以此排列，这些区别主要由对冲突的处理能力引起。LR Parser的逻辑和LL Parser有所不同，LL Parser（如果带求值），会维护两个栈，一个符号栈，里面存的是未终止符号+语义行为，另一个数值栈，用于求值（语义行为的作用对象）。而LR Parser维护的两个栈（尚不考虑求值）存放的是状态（状态之所以要用栈是要保留历史，不然规约时没有参考对象，比如P->AB，则规约出B后还需要之前得到A的状态来进一步规约出B）和规约的符号，即到这个未知，这个Parser可能在解析什么内容。由于LR Parser的解析器结构中会存在两张表，一张ACTION表，用于表示碰到状态碰到终结符后做什么事情（移进还是规约），一张GOTO表，表示碰到非终结符后做什么事情（规约到什么状态）。

呃呃，其实LR语法也有些奇怪的限制。

ACTION GOTO中状态的求解需要了解Item、Closure、GOTO的概念，这个不妨去问问AI。

LR(0) 不处理规约移进冲突（E -> id + id ; E -> id，读完第一个id 要不要规约？）

SLR   LR(0)的升级，结构与LR(0)一直，遇到冲突时，查询FOLLOW Sets来决定选择规约还是移进，(我要规约出E，后面的符号必须存在于E的Follow Set)，当然这个解决方法并不完全。

```  
FOLLOW Sets可以解决:
  E -> id + E | id 在1+2+3中1时的规约移进冲突
不能解决:
  E -> E + id | id 在1+2+3中2时的规约规约冲突
  (当然可以用Longest Match解决)
  但如果使用LALR，就可以解决这个问题:
  [E -> E + id, $] , [E -> id, +$]
  LALR通常自动推导lookahead，当然你也可以手动指定lookahead进行人为干预 
```

LALR  LR(1)的简化，结构与LR(1)一致，但合并了一些状态，使最终状态数与LR(0),SLR解析器一致，在LALR与LR(1)中，新项目除了携带原项目（如S -> .E ）外还要携带一个合法规约向前看（LookAhead）两者结合起来大概变成类似于[S -> .E,$]的形式，然后由这些东西求闭包得到整个状态。与SLR的区别在于，LALR的规约限制允许同一种符号在规约前后有不同的向前看约束，即[A -> .B,+],[A -> .C,*]，而对于SLR, FollowSet["A"] = {\+\*}不能区分这样的情况。

LR(1) 在LALR中，[A -> .B,+],[A -> .B,*]会被合并成为[A -> .B,\+\*]以减少状态数，而在LR(1)中，这两者的差异被保留，这使得LR(1)有比LALR更强的记忆力（或者说上下文关联能力，不过这个上下文和上下文关联语法的上下文概念并不一致），但代价是这样做LR(1)容易状态爆炸。

LR 与 LL 最大的区别还是在于Top-Down与Bottom-Up。

LR语法对左右结合的处理有两种方式：
  1. 因为 LR 对 文法没有特别严苛的要求，可以直接修改生成式文法以实现优先级修改。
    (对于LALR与LR(1)，也可以修改Lookahead进行干预)
  2. 左右结合性本质上也是冲突,如E -> E + E ; E -> id
  那么对于 id + id + id，在第一个+时就有移进与规约冲突（左边的E算id + id还是右边的E算id + id），这时手动规定优先级，就可以解决结合性问题。
  
LR 无法像 LL 那样修改 ACTION 的插入位置来解决结合性问题，LR能够执行语义动作的时间只有规约时。

补充说明:
  LR Parser和FA一样，不一定要将这些状态全部在编译期求解掉（参考DFA，就是对NFA做闭包;
  ACTION GOTO 状态表也是靠闭包得来的），而可以在运行时手动求解，如NFA。

好奇怪，LL怎么不需要闭包，思考一下，闭包通常是在"有多种可能"的时候才做，
而LL Parser依靠Lookahead限制到了仅一种状态，所以通常不需要闭包，当然，如果什么鬼语法让LL也有多种可能展开，那么闭包就可以引入了。

好吧，白写了个LRTableGen。LR(0) 语法总是移进，移进后再检查规约，我们常见的ACTION, GOTO表其实是SLR的设计，他会偷看下一个来决定之前的行为，比如偷看到+才决定规约上一个符号。LR(0)和SLR/LALR/LR(1)的运行时处理机制是有区别的。

## 语法的四个层级

|名称|实现方法|特征| 
|---|---|---| 
| RL 正则语言       | FA (NFA,DFA) 有限自动机 | 有限的起点+有限的三种操作 |
| CFG 上下文无关文法 | LL(1) LL(k) LL(*) ; LR(0) SLR LALR LR(1) 取决于具体实现，大都离不开栈，或者下降自动机PDA | 生成式规则与上下文无关,部分实现对生成式文法有要求 |
| CSG 上下文相关文法 (说实在不如感觉到前后文，或者前后缀) | LBA (已经属于理论模型，相当于空间受限的图灵机) | 生成式与上下文有关，比如只有aXb才能规约成为aZb |
| 自由语法 | 图灵机 | 图灵完备，啥限制没有 |

